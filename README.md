# HERO!N Messenger

[![Go](https://img.shields.io/badge/Go-1.21+-blue.svg)](https://golang.org) [![Kotlin](https://img.shields.io/badge/Kotlin-1.9+-purple.svg)](https://kotlinlang.org) [![LibP2P](https://img.shields.io/badge/LibP2P-0.32+-green.svg)](https://libp2p.io) [![IPFS](https://img.shields.io/badge/IPFS-0.20+-yellow.svg)](https://ipfs.io) [![WebRTC](https://img.shields.io/badge/WebRTC-1.0+-red.svg)](https://webrtc.org) [![Docker](https://img.shields.io/badge/Docker-Ready-blue.svg)](https://docker.com) [![License](https://img.shields.io/badge/License-GPL--3.0-green.svg)](LICENSE) [![PRs Welcome](https://img.shields.io/badge/PRs-Welcome-brightgreen.svg)](CONTRIBUTING.md)

**Незаблокируемый P2P месенджер с E2E шифрованием и автономным режимом**

*Мы активно разрабатываем эту систему - это не готовый продукт, а текущий процесс создания.*

**Технологии:** Go 1.21+ | LibP2P 0.32+ | IPFS 0.20+ | WebRTC | Kotlin 1.9+ | ChaCha20-Poly1305 | Docker | i2p/tor

**Протоколы:** QUIC | WebRTC | TCP/HTTP2 | LibP2P | Noise Protocol | Kademlia DHT

## Архитектура

### Сетевая топология - Обширная Децентрализованная Сеть

#### 1. Многослойная Архитектура Сети

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Глобальная сеть HERO!N                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  Уровень 4: Прикладные сервисы (Application Layer)                        │
│  ┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐ │
│  │  Message Relay │  File Transfer │  Voice/Video    │  Group Chat     │ │
│  │     Service    │    Service     │    Service      │   Service       │ │
│  └─────────────────┴─────────────────┴─────────────────┴─────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│  Уровень 3: Overlay сети (Overlay Networks)                               │
│  ┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐ │
│  │   P2P Overlay  │    DHT Overlay  │  IPFS Overlay   │  Relay Overlay  │ │
│  │   (LibP2P)    │   (Kademlia)   │   (IPFS)       │   (TURN/STUN)   │ │
│  └─────────────────┴─────────────────┴─────────────────┴─────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│  Уровень 2: Транспорт и безопасность (Transport & Security)              │
│  ┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐ │
│  │     QUIC      │     WebRTC     │    TLS 1.3     │   Noise Proto   │ │
│  │  (UDP-based)  │  (P2P over NAT)│   (Encryption) │ (Handshake)     │ │
│  └─────────────────┴─────────────────┴─────────────────┴─────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│  Уровень 1: Физическая сеть (Physical Network)                           │
│  ┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐ │
│  │   Ethernet    │     Wi-Fi      │   Cellular     │   Satellite     │ │
│  │   (LAN)       │   (Local)      │   (Mobile)     │   (Backup)      │ │
│  └─────────────────┴─────────────────┴─────────────────┴─────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 2. Географическая Распределенность Сети

```
🌍 Европа                           🌎 Северная Америка                 🌏 Азия
┌─────────────────┐               ┌─────────────────┐               ┌─────────────────┐
│  🇩🇪 Bootstrap  │               │   🇺🇸 Bootstrap  │               │   🇯🇵 Bootstrap  │
│   Frankfurt    │◄─────────────►│    New York     │◄─────────────►│    Tokyo       │
│                 │               │                 │               │                 │
│  🇳🇱 Relay Node │               │   🇨🇦 Relay Node │               │   🇰🇷 Relay Node │
│  Amsterdam     │               │    Toronto      │               │    Seoul       │
│                 │               │                 │               │                 │
│  🇫🇷 Storage    │               │   🇲🇽 Storage    │               │   🇸🇬 Storage    │
│   Paris        │               │    Mexico       │               │  Singapore     │
└─────────────────┴───────────────┴─────────────────┴───────────────┴─────────────────┘
         │                               │                               │
         └───────────────────┬───────────┼───────────────┬───────────────┘
                             │           │               │
                        🌍 Африка     🌏 Австралия    🌎 Южная Америка
                       ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
                       │   🇿🇦 Bootstrap  │ │   🇦🇺 Bootstrap  │ │   🇧🇷 Bootstrap  │
                       │   Cape Town     │ │    Sydney       │ │    Sao Paulo    │
                       │                 │ │                 │ │                 │
                       │   🇪🇬 Relay Node │ │   🇳🇿 Relay Node │ │   🇦🇷 Relay Node │
                       │    Cairo        │ │  Wellington     │ │  Buenos Aires   │
                       │                 │ │                 │ │                 │
                       │   🇰🇪 Storage    │ │   🆕 Storage    │ │   🇨🇱 Storage    │
                       │   Nairobi       │ │   Auckland      │ │   Santiago      │
                       └─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

#### 3. Типы Узлов и Их Роли

##### Bootstrap Nodes (Точки входа)
- **Discovery Points** - начальные точки для новых клиентов
- **Server Registry** - реестр всех активных серверов
- **Health Monitoring** - проверка доступности других узлов
- **Load Balancing** - распределение нагрузки между серверами
- **Fallback Points** - резервные точки при сбоях

##### Relay Nodes (Реле/Транзитные узлы)
- **NAT Traversal** - помощь в обходе NAT через STUN/TURN
- **Traffic Routing** - маршрутизация трафика при сложности P2P
- **Bandwidth Optimization** - оптимизация пропускной способности
- **Connection Multiplexing** - мультиплексирование соединений

##### Storage Nodes (Узлы хранения)
- **IPFS Gateways** - шлюзы для доступа к IPFS сети
- **File Storage** - хранение зашифрованных файлов
- **Content Replication** - репликация контента
- **Space-Time Proofs** - доказательства хранения
- **Caching** - кеширование популярного контента

##### Community Nodes (Узлы сообщества)
- **User-operated** - управляются энтузиастами
- **Local Caching** - локальное кеширование контента
- **Regional Boost** - улучшение производительности в регионе
- **Backup Services** - резервные сервисы
- **Reputation System** - система репутации

#### 4. Протоколы Соединений и Транспорта

##### Основные Протоколы
```
┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   Протокол     │   Использование │   Преимущества │   Ограничения  │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│     QUIC       │  Быстрый транспорт│ 0-RTT, UDP    │  Новизна       │
│     WebRTC     │ P2P через NAT   │ Нативный P2P  │  Сложность     │
│     TCP/HTTP2  │  Резервный      │  Устойчивость  │  Задержка      │
│     WebSocket  │  Real-time      │  Дуплекс      │  Overhead      │
│     i2p/tor    │  Анонимность    │  Privacy      │  Производительность │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

##### Слои Безопасности
```
┌─────────────────────────────────────────────────────────────────────┐
│                    Слои безопасности сети                          │
├─────────────────────────────────────────────────────────────────────┤
│  Уровень 7: Application Security                                  │
│  ├─ E2E шифрование (ChaCha20-Poly1305)                           │
│  ├─ Zero-Knowledge Proofs                                        │
│  └─ Message Authentication                                       │
├─────────────────────────────────────────────────────────────────────┤
│  Уровень 6: Transport Security                                     │
│  ├─ TLS 1.3 (для TCP соединений)                                │
│  ├─ DTLS (для UDP/QUIC)                                         │
│  └─ Noise Protocol (для P2P handshake)                          │
├─────────────────────────────────────────────────────────────────────┤
│  Уровень 5: Network Security                                       │
│  ├─ IPFS Private Networks                                       │
│  ├─ LibP2P Private Swarms                                       │
│  └─ Tor Hidden Services                                         │
├─────────────────────────────────────────────────────────────────────┤
│  Уровень 4: Physical Security                                      │
│  ├─ Geographic Distribution                                      │
│  ├─ Server Hardening                                            │
│  └─ DDoS Protection                                             │
└─────────────────────────────────────────────────────────────────────┘
```

#### 5. Маршрутизация и Трафик

##### Intelligent Routing System
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Source Node   │───▶│  Routing Engine │───▶│ Destination Node│
│                 │    │                 │    │                 │
│ • User Device   │    │ • Path Finding  │    │ • Other Device  │
│ • Mobile App    │    │ • Load Balance  │    │ • Server        │
│ • Low Latency   │    │ • QoS Aware     │    │ • Storage       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Direct P2P    │    │   Via Relay     │    │  Via Bootstrap  │
│   (Optimal)    │    │   (Fallback)    │    │   (Discovery)   │
└─────────────────┘    └─────────────────┴─────────────────┘
```

##### Adaptive Path Selection
- **Latency-based** - выбор пути с минимальной задержкой
- **Bandwidth-aware** - учет пропускной способности
- **Reliability-first** - приоритет надежности
- **Cost-optimized** - экономическая оптимизация
- **Geographic preference** - предпочтение близких узлов

### Команда
- Группа: x.d.e.r (xder.c0rex64.dev)
- Основатель: c0re
- Открыты для энтузиастов и сообщества

### Система Серверов - Децентрализованная Инфраструктура

Мы строим сложную распределенную систему, где каждый тип серверов имеет свою специализацию и работает автономно.

#### 1. Bootstrap Nodes - Точки входа в сеть
- **Децентрализованные точки входа** - любой может запустить свой bootstrap сервер для надежности
- **Географическое распределение** - серверы размещены в разных странах и дата-центрах
- **Автоматическая синхронизация** - все bootstrap серверы обмениваются информацией через DHT
- **Федеративная структура** - нет единого владельца, все участники равноправны
- **Резервные копии** - при падении одного сервера другие продолжают работу

#### 2. Relay Nodes - Транзитные узлы для соединений
- **STUN/TURN серверы** - помогают устройствам находить друг друга через NAT
- **Балансировка нагрузки** - умное распределение трафика между доступными серверами
- **Географическая оптимизация** - выбор relay сервера с минимальной задержкой
- **Автоматическое масштабирование** - добавление новых серверов при росте нагрузки
- **Health monitoring** - постоянная проверка работоспособности и доступности

#### 3. Storage Nodes - Распределенное хранение файлов

##### IPFS с многоуровневым шифрованием
- **Block-level encryption** - каждый блок шифруется отдельно перед загрузкой в IPFS
- **ChaCha20-Poly1305** - высокопроизводительное симметричное шифрование для файлов
- **Unique encryption keys** - каждый файл имеет свой уникальный ключ шифрования
- **Key derivation** - ключи генерируются из мастер-ключа через HKDF для безопасности
- **Content-addressing** - файл ищется по хэшу зашифрованного контента для верификации

##### Распределенное хранение с резервированием
- **IPFS кластер** - файлы хранятся на множестве storage nodes одновременно
- **Репликация** - каждый файл копируется на 3-5 серверов для надежности
- **Geographic distribution** - файлы распределяются по разным регионам для устойчивости
- **Deduplication** - одинаковые файлы хранятся только один раз для экономии места
- **Версионирование** - история изменений через IPFS MFS для восстановления

##### Space-time proofs для надежности хранения
- **Proof of Storage** - криптографическое доказательство того, что файл хранится
- **Space proofs** - доказательства выделенного места для файла
- **Time proofs** - доказательства хранения файла в течение определенного времени
- **Challenge-response** - регулярные криптографические проверки хранилищ
- **Slashing mechanism** - система штрафов за невыполнение обязательств хранения

#### 4. Community Nodes - Серверы от сообщества
- **От энтузиастов** - обычные люди запускают серверы у себя дома или в офисах
- **Кеширование популярного контента** - часто запрашиваемые файлы хранятся ближе к пользователям
- **Репутационная система** - надежные серверы получают больше трафика и доверия
- **Баллы за uptime** - чем дольше сервер работает без сбоев, тем он надежнее
- **Локальные зеркала** - копирование контента в конкретных регионах для скорости

### Discovery Механизм - Как устройства находят друг друга

Это распределенная система поиска, которая работает автоматически и адаптируется к изменениям в сети:

#### 1. Первичное подключение (Bootstrap Discovery)
- **Хардкоженные серверы** - приложение знает 3-5 публичных bootstrap серверов
- **Параллельные попытки** - пытается подключиться ко всем сразу
- **Географический выбор** - выбирает ближайший по пингу
- **Резервные варианты** - если первый недоступен, пробует следующий

#### 2. Регистрация новых серверов (Server Registration)
- **Валидация** - новый сервер доказывает свою надежность
- **DHT регистрация** - сервер записывает себя в распределенную хэш-таблицу
- **Объявление соседям** - оповещает другие серверы о своем появлении
- **Получение репутации** - начинает с базового уровня доверия

#### 3. Обмен информацией (Peer Exchange)
- **Gossip протокол** - серверы делятся информацией друг с другом
- **Обновление списков** - постоянное обновление списка доступных серверов
- **Фильтрация по качеству** - отсеивание проблемных серверов
- **Географическая оптимизация** - предпочтение близких серверов

#### 4. Проверка здоровья (Health Checks)
- **Периодические проверки** - каждые 30 секунд проверка доступности
- **Метрики производительности** - скорость ответа, время работы, нагрузка
- **Автоматическое исключение** - неработающие серверы убираются из списка
- **Восстановление** - вернувшиеся серверы добавляются обратно

### HERO Protocol v1.0 - Наш специальный протокол для авто-роутинга

Мы активно разрабатываем собственный протокол, который специально оптимизирован для наших нужд. Это не просто набор существующих протоколов, а интегрированная система с уникальными алгоритмами. Мы создаем это с нуля для достижения максимальной эффективности и надежности нашей сети.

#### Core Features - Основные возможности

##### 1. Adaptive Network Intelligence (Адаптивный сетевой интеллект)
- **Real-time Network Monitoring** - постоянный мониторинг состояния сети
- **Latency Measurements** - измерение задержек до всех узлов
- **Bandwidth Testing** - тестирование пропускной способности
- **Packet Loss Detection** - обнаружение потерь пакетов
- **Node Health Checks** - проверка здоровья всех узлов

##### 2. Multi-objective Path Optimization (Многоцелевая оптимизация путей)
- **Minimize Latency** - минимизация задержки для быстрой доставки
- **Maximize Bandwidth** - максимизация пропускной способности
- **Minimize Packet Loss** - минимизация потерь пакетов
- **Maximize Reliability** - максимизация надежности соединения
- **Cost Optimization** - оптимизация стоимости передачи

##### 3. Geographic Routing Intelligence (Географический интеллект маршрутизации)
- **Continent-aware Routing** - маршрутизация с учетом континентов
- **Regional Preferences** - предпочтения для близких регионов
- **Latency-based Selection** - выбор на основе измеренной задержки
- **Backup Route Planning** - планирование резервных маршрутов
- **Cross-border Optimization** - оптимизация межграничного трафика

##### 4. Machine Learning Integration (Интеграция машинного обучения)
- **Historical Data Analysis** - анализ исторических данных о сети
- **Pattern Recognition** - распознавание паттернов поведения сети
- **Predictive Routing** - предиктивная маршрутизация
- **Self-learning Optimization** - самообучающаяся оптимизация
- **Anomaly Detection** - обнаружение аномалий в сети

##### 5. Adaptive Route Management (Адаптивное управление маршрутами)
- **Continuous Performance Monitoring** - непрерывный мониторинг производительности
- **Threshold-based Triggers** - триггеры на основе пороговых значений
- **Seamless Handover** - бесшовное переключение между маршрутами
- **Route Quality Assessment** - оценка качества маршрута
- **Dynamic Route Updates** - динамические обновления маршрутов

#### Technical Implementation - Техническая реализация

##### Network Resilience Engine (Движок сетевой устойчивости)
```go
// Основные компоненты нашего протокола
type HEROProtocol struct {
    networkMonitor   *NetworkMonitor
    pathCalculator   *PathCalculator
    routeManager     *RouteManager
    mlEngine         *MLEngine
    resilienceEngine *ResilienceEngine
}

// Core routing algorithm
func (hp *HEROProtocol) CalculateOptimalPath(
    source, destination string,
    constraints *RoutingConstraints,
) (*OptimalPath, error) {

    // 1. Gather real-time network metrics
    metrics := hp.networkMonitor.GetMetrics(source, destination)

    // 2. Calculate multiple path candidates
    candidates := hp.pathCalculator.FindCandidates(metrics, constraints)

    // 3. Apply ML predictions and historical data
    predictions := hp.mlEngine.PredictPerformance(candidates)

    // 4. Select optimal path with fallback options
    optimalPath := hp.routeManager.SelectOptimal(candidates, predictions)

    // 5. Plan backup routes for resilience
    optimalPath.Backups = hp.resilienceEngine.PlanBackups(optimalPath)

    return optimalPath, nil
}
```

##### Adaptive Learning System (Система адаптивного обучения)
```go
// Machine learning component for route optimization
type MLEngine struct {
    historicalData *TimeSeriesDB
    patternMatcher *PatternMatcher
    predictor      *PerformancePredictor
}

// Learn from network performance
func (ml *MLEngine) LearnFromExperience(
    path *Path,
    performance *PerformanceMetrics,
) {
    // Store performance data
    ml.historicalData.Store(path, performance)

    // Update pattern recognition
    ml.patternMatcher.UpdatePatterns(path, performance)

    // Improve predictions
    ml.predictor.Train(path, performance)
}
```

##### Real-time Route Switching (Переключение маршрутов в реальном времени)
work,later.

#### Key Advantages - Ключевые преимущества

##### 1. Intelligent Path Selection (Умный выбор пути)
- Анализирует реальное состояние сети, а не полагается на статические метрики
- Учитывает множество факторов одновременно для оптимального выбора
- Адаптируется к изменяющимся условиям в реальном времени

##### 2. Predictive Capabilities (Предиктивные возможности)
- Использует машинное обучение для предсказания будущих состояний сети
- Предотвращает проблемы до их возникновения
- Оптимизирует на основе исторических данных

##### 3. Geographic Awareness (Географическая осведомленность)
- Понимает географическую топологию сети
- Оптимизирует маршруты с учетом физического расположения
- Минимизирует задержки через умное географическое планирование

##### 4. Self-healing Mechanisms (Механизмы самовосстановления)
- Автоматически обнаруживает и исправляет проблемы
- Создает резервные маршруты заранее
- Восстанавливается после сбоев без участия человека

##### 5. Multi-objective Optimization (Многоцелевая оптимизация)
- Балансирует между скоростью, надежностью и стоимостью
- Приспосабливается к разным типам трафика
- Оптимизирует под конкретные требования приложения

### P2P Сеть - Прямое общение между устройствами

Это позволяет устройствам общаться напрямую, без промежуточных серверов:

#### LibP2P - Универсальный P2P протокол
- **Модульная архитектура** - можно менять компоненты
- **Множество транспортов** - TCP, QUIC, WebRTC, WebSocket
- **Встроенная безопасность** - TLS 1.3, Noise Protocol
- **Кроссплатформенность** - работает на всех устройствах

#### Kademlia DHT - Умная система маршрутизации
- **Распределенная хэш-таблица** - как BitTorrent, но для всего
- **Логарифмическая сложность** - быстрый поиск любого узла
- **Fault tolerance** - продолжает работать при падении узлов
- **Self-organizing** - сама себя оптимизирует

#### WebRTC - P2P через NAT
- **NAT traversal** - находит путь через роутеры и firewall
- **ICE (Interactive Connectivity Establishment)** - умный выбор пути
- **STUN/TURN fallback** - если прямое соединение невозможно
- **DTLS шифрование** - встроенная безопасность

#### QUIC - Быстрый и надежный транспорт
- **UDP-based** - работает даже при плохом интернете
- **Built-in security** - TLS 1.3 из коробки
- **Connection migration** - переключение сетей без разрыва
- **0-RTT handshake** - мгновенное подключение при повторных визитах

### Безопасность - Многослойная защита

Система безопасности использует многослойный подход, где каждый уровень добавляет дополнительную защиту:

#### Криптография - Основа безопасности
- **ChaCha20-Poly1305** - симметричное шифрование (быстрее AES)
- **X25519** - ECDH для обмена ключами (пост-квантовая безопасность)
- **Ed25519** - цифровые подписи (компактные и быстрые)
- **HKDF** - генерация ключей из мастер-ключа

#### Zero-Knowledge архитектура
- **Сервер не знает ключи** - даже мы не можем прочитать сообщения
- **Perfect Forward Secrecy** - каждый день новые ключи для сессий
- **Forward Secrecy** - компрометация одного ключа не ломает все
- **Ephemeral keys** - временные ключи для каждого соединения

#### Дополнительные механизмы
- **Plausible deniability** - можно отрицать отправку сообщения
- **Quantum resistance** - подготовка к квантовым компьютерам
- **Post-quantum crypto** - алгоритмы на будущее
- **Metadata protection** - защита даже от анализа паттернов

#### Файловое шифрование (IPFS Encryption Layer)
- **File-level encryption** - шифрование всего файла перед фрагментацией
- **Block-level encryption** - дополнительное шифрование каждого блока
- **Key separation** - разные ключи для разных уровней шифрования
- **Key management** - безопасное хранение и передача ключей
- **Perfect forward secrecy** - старые ключи не компрометируют новые файлы

## Space-Time Proofs - Доказательство хранения

### Что такое Space-Time Proofs

Space-time proofs - это криптографические механизмы, доказывающие что:
- **Space proofs** - файл действительно хранится на сервере (занимает место)
- **Time proofs** - файл хранится в течение определенного времени
- **Availability proofs** - файл доступен для загрузки

### Как это работает в HERO!N

#### 1. Filecoin-inspired approach (адаптированный для IPFS)
- **Sealing** - файл запечатывается с proof-of-replication
- **PoRep (Proof of Replication)** - доказательство, что файл реплицирован
- **PoSt (Proof of Space-Time)** - доказательство хранения во времени

#### 2. Storage verification
```go
```

#### 3. Slashing mechanism
- **Storage nodes** должны регулярно доказывать хранение
- **Missed proofs** ведут к снижению репутации
- **Repeated failures** исключают из сети
- **Economic incentives** - хорошие storage nodes получают больше файлов

#### 4. Redundancy through replication
- **Multiple copies** - каждый файл хранится на 3+ серверах
- **Geographic diversity** - копии в разных регионах
- **Independent verification** - разные серверы проверяют друг друга
- **Dynamic replication** - новые копии при падении серверов

### Преимущества Space-Time Proofs

#### Для пользователей
- **Guaranteed availability** - файлы всегда доступны
- **Data persistence** - файлы не теряются
- **Fast retrieval** - оптимизированные запросы
- **Cost efficiency** - эффективное использование storage

#### Для storage nodes
- **Reputation building** - хорошая репутация = больше трафика
- **Automated management** - система сама управляет storage

#### Для сети
- **Decentralized reliability** - надежность без централизации
- **Self-healing** - сеть восстанавливается автоматически
- **Economic security** - экономические стимулы поддерживают надежность

## Как это работает на практике - Реальные сценарии
later.

### Сценарий 1: Первый запуск приложения

**Что происходит:**
1. **Скачивание и установка** - пользователь скачивает APK из GitHub releases
2. **Инициализация** - приложение запускается и начинает поиск сети
3. **Bootstrap discovery** - пытается подключиться к 3-5 хардкоженным bootstrap серверам
4. **Географический выбор** - выбирает сервер с минимальным пингом (скажем, в Европе)
5. **Получение списка** - bootstrap сервер возвращает список 50+ активных серверов
6. **DHT подключение** - подключается к DHT сети через выбранный сервер
7. **Peer discovery** - получает информацию о других пользователях онлайн

**Время:** 10-30 секунд от запуска до готовности к общению

### Сценарий 2: Отправка сообщения

**Что происходит:**
1. **Шифрование** - сообщение шифруется ChaCha20-Poly1305 с уникальным ключом
2. **Подпись** - добавляется цифровая подпись Ed25519 для аутентификации
3. **Маршрутизация** - через Kademlia DHT ищется путь к получателю
4. **P2P соединение** - устанавливается прямое WebRTC соединение
5. **Передача** - сообщение отправляется по QUIC для надежности
6. **Подтверждение** - получатель подтверждает получение
7. **Хранение** - сообщение сохраняется локально у обоих пользователей

**Время:** 100-500мс для доставки в хороших условиях

### Сценарий 3: Когда что-то ломается - Bootstrap серверы заблокированы

**Что происходит:**
1. **Обнаружение проблемы** - приложение не может подключиться к основным bootstrap
2. **Резервные серверы** - использует дополнительные хардкоженные серверы
3. **i2p/tor fallback** - подключается через анонимную сеть
4. **Community nodes** - ищет известные community серверы
5. **Локальная сеть** - переходит в автономный режим через Wi-Fi
6. **Восстановление** - как только один сервер становится доступен, синхронизируется

**Время:** 1-5 минут для восстановления в экстремальных условиях

### Сценарий 4: Массовый сбой серверов

**Что происходит:**
1. **Обнаружение** - приложение видит, что многие серверы недоступны
2. **Репутационная система** - отсеивает проблемные серверы
3. **Географическая диверсификация** - подключается к серверам в других регионах
4. **Community activation** - активируются серверы от энтузиастов
5. **Автоматическое масштабирование** - bootstrap серверы добавляют новые узлы
6. **Восстановление сети** - постепенно сеть приходит в норму

**Время:** 5-30 минут для полного восстановления

### Сценарий 5: Отправка файла

**Что происходит:**
1. **Генерация ключа** - создается уникальный ключ шифрования для файла через HKDF
2. **Шифрование** - файл шифруется ChaCha20-Poly1305 с уникальным ключом
3. **Фрагментация** - зашифрованный файл разбивается на блоки по 256KB
4. **Block-level encryption** - каждый блок дополнительно шифруется своим ключом
5. **IPFS загрузка** - зашифрованные блоки загружаются в IPFS сеть
6. **DAG assembly** - создается Directed Acyclic Graph структуры файла
7. **Получение CID** - генерируется Content Identifier (хэш корневого блока)
8. **Ключ шифрования** - ключ шифрования отправляется отдельно через E2E канал
9. **Metadata** - отправляется зашифрованная ссылка с CID + метаданные
10. **Загрузка получателем** - получатель скачивает блоки по CID из IPFS
11. **Расшифровка** - получатель расшифровывает блоки используя полученный ключ
12. **Верификация** - проверка целостности через хэш оригинального файла

**Время:** 30 секунд - 5 минут в зависимости от размера файла

**Безопасность:**
- Файл шифруется до загрузки в IPFS - даже storage nodes не видят контент
- Ключ шифрования передается отдельно через защищенный E2E канал
- IPFS видит только зашифрованные блоки - perfect forward secrecy

### Сценарий 5.1: Space-Time Proofs в действии

**Что происходит:**
1. **Storage node registration** - сервер регистрируется как storage provider
2. **File sealing** - файл запечатывается с proof-of-replication
3. **Initial replication** - файл копируется на 3 разных storage nodes
4. **Periodic challenges** - каждый час система отправляет challenge
5. **Proof generation** - storage node генерирует proof хранения
6. **Verification** - другие nodes проверяют proof
7. **Reputation update** - успешные proofs повышают репутацию
8. **Dynamic replication** - при падении node создаются новые копии

**Время:** Verification занимает ~100ms, происходит каждые 15-60 минут

### Сценарий 6: Работа в автономном режиме

**Что происходит:**
1. **Обнаружение** - приложение понимает, что нет интернета
2. **mDNS discovery** - ищет другие устройства в локальной сети
3. **Wi-Fi Direct** - устанавливает прямые P2P соединения
4. **Локальный DHT** - создает мини-сеть в рамках Wi-Fi
5. **Синхронизация** - обменивается сообщениями с найденными устройствами
6. **Кеширование** - сохраняет сообщения для отправки позже
7. **Восстановление** - при появлении интернета синхронизируется с основной сетью

**Ограничения:** Только локальные пользователи, офлайн сообщения

## Техническая Архитектура

### Bootstrap Server
```go
// Основные компоненты
- HTTP API для регистрации клиентов
- LibP2P для P2P соединений
- PostgreSQL для метаданных
- Redis для кеширования
- Docker для развертывания
```

### Android Client
```kotlin
// Архитектура
- MVVM с Jetpack Compose
- Room для локального хранения
- WebRTC для P2P
- ChaCha20-Poly1305 для шифрования
- IPFS Lite для файлов
```

### Storage Node (IPFS + Space-Time Proofs)
```go
```

### Система Discovery
```
1. Клиент -> Bootstrap Server (запрос списка серверов)
2. Bootstrap -> DHT Network (поиск активных серверов)
3. DHT -> Client (список доступных серверов)
4. Client -> Server (прямое подключение)
```

## Защита от Блокировок

### Многоуровневая Защита
1. **Транспортный уровень** - i2p/tor для bootstrap
2. **Сетевой уровень** - WebRTC + TURN для P2P
3. **Прикладной уровень** - Obfuscation + Padding
4. **Социальный уровень** - Community servers + Caching

### Автономный Режим
- **Локальная сеть** - обнаружение через mDNS/Bonjour
- **Wi-Fi Direct** - прямое P2P соединение
- **Локальный DHT** - мини-сеть в рамках Wi-Fi

## Масштабируемость

### Горизонтальное Масштабирование
- **Stateless дизайн** - легкое добавление серверов
- **Load balancing** - распределение нагрузки
- **Geographic distribution** - серверы по всему миру
- **Auto-scaling** - автоматическое масштабирование

### DHT Оптимизации
- **Adaptive routing** - адаптивная маршрутизация
- **Node health checks** - проверка здоровья узлов
- **Reputation system** - система репутации
- **Backup routes** - резервные маршруты

## Мониторинг и Observability

### Метрики
- **Network health** - здоровье сети
- **Message delivery rate** - процент доставки
- **Latency metrics** - задержки
- **Node churn** - текучесть узлов

### Логирование
- **Structured logging** - структурированные логи
- **Distributed tracing** - распределенное трассирование
- **Security events** - события безопасности
- **Performance monitoring** - мониторинг производительности
---

## Присоединяйся к разработке!

**Мы ищем:**
- Backend разработчиков (Go)
- Android разработчиков (Kotlin)
- DevOps инженеров
- Security экспертов
- Энтузиастов и тестировщиков

**Требования:**
- Понимание P2P сетей
- Опыт с криптографией
- Знание сетевых протоколов
- Интерес к децентрализованным системам

**Как начать:**
1. Ознакомься с архитектурой выше
2. Выбери интересующую область
3. Напиши issue или PR

**Контакты:**
- GitHub: https://github.com/xder/HERO-N

## Лицензия

Этот проект распространяется под лицензией GPL-3.0. Подробности в файле [LICENSE](LICENSE).

## Вклад в проект

Мы приветствуем вклад от сообщества! Прочитайте [CONTRIBUTING.md](CONTRIBUTING.md) для получения информации о том, как начать.

### Как запустить локально

```bash
# Клонировать репозиторий
git clone https://github.com/xder/HERO-N.git
cd HERO-N

# Запустить bootstrap сервер
docker-compose up bootstrap

# Собрать Android клиент
cd mobile && ./gradlew assembleDebug
```


## Почему эту систему нельзя сломать - Анализ устойчивости

### Техническая неубиваемость

#### 1. Децентрализация - Нет единой точки отказа
- **Сеть как организм** - если убрать один узел, другие продолжают работать
- **Федеративная структура** - нет центрального владельца
- **Автоматическое восстановление** - сеть сама себя чинит
- **Географическая распределенность** - серверы в разных юрисдикциях

#### 2. P2P архитектура - Прямое общение
- **Без посредников** - сообщения идут напрямую между людьми
- **Не зависит от серверов** - работает даже если все серверы упали
- **Самоорганизующаяся** - сама находит оптимальные пути
- **Масштабируемая** - чем больше пользователей, тем надежнее

#### 3. Многослойная защита от блокировок
- **Транспортный уровень** - i2p/tor для обхода
- **Сетевой уровень** - WebRTC + TURN для P2P
- **Прикладной уровень** - Obfuscation + шифрование
- **Социальный уровень** - Community servers + кеширование

#### 4. Zero-knowledge безопасность
- **Сервер ничего не знает** - даже мы не можем прочитать сообщения
- **Perfect Forward Secrecy** - старые ключи бесполезны
- **Quantum-resistant** - готово к будущим угрозам
- **Metadata protection** - защищает даже паттерны использования

### Социальная неубиваемость

#### 1. Открытый исходный код
- **Прозрачность** - любой может проверить безопасность
- **Независимость** - не зависит от одной компании
- **Сообщество** - энтузиасты поддерживают и улучшают
- **Философия** - свобода коммуникаций превыше всего

#### 2. Распределенное владение
- **Community nodes** - серверы от обычных людей
- **Децентрализованное управление** - решения принимаются сообществом
- **Экономические стимулы** - баллы за надежность серверов
- **Репутационная система** - хорошая репутация = больше трафика

#### 3. Техническая грамотность сообщества
- **Обучение** - объясняем как все работает простым языком
- **Документация** - подробные инструкции для запуска серверов
- **Поддержка** - помощь новичкам в настройке
- **Вовлеченность** - каждый может внести свой вклад

### Реалистичные угрозы и ответы

#### Угроза: Блокировка всех bootstrap серверов
**Ответ:** i2p/tor + резервные серверы + автономный режим

#### Угроза: Компрометация ключей
**Ответ:** Perfect Forward Secrecy + quantum-resistant crypto

#### Угроза: DDoS атаки
**Ответ:** Географическая распределенность + rate limiting

#### Угроза: Правовые ограничения
**Ответ:** Zero-knowledge + распределенное владение + международная структура

#### Угроза: Технический прогресс (квантовые компьютеры)
**Ответ:** Post-quantum cryptography + постоянные обновления

#### Угроза: Storage node failures (выход из строя серверов хранения)
**Ответ:** Space-time proofs + replication + dynamic recovery

#### Угроза: Data loss (потеря файлов)
**Ответ:** Multiple replicas + geographic distribution + verification

### Заключение

Эта система **практически неубиваема** не потому, что она идеальна, а потому, что она:

- **Технически грамотна** - использует проверенные решения
- **Социально устойчива** - поддерживается сообществом
- **Адаптивна** - может меняться и улучшаться
- **Прозрачна** - любой может понять и проверить

**HERO!N** - это не просто месенджер, это **эксперимент** в создании по-настоящему свободной коммуникационной инфраструктуры XXI века. Мы находимся в активной фазе разработки и тестирования всех этих технологий.

**Space-Time Proofs добавляют:**
- **Криптографическую надежность** - математически доказанное хранение
- **Экономические стимулы** - вознаграждение за честность
- **Самовосстановление** - автоматическое восстановление потерянных данных
- **Доверие без центра** - децентрализованная верификация

**В итоге получаем систему, где:**
- Файлы хранятся надежно без центральных серверов
- Хранение доказывается криптографически
- Система восстанавливается автоматически
- Экономические стимулы поддерживают надежность

---

## Текущий статус разработки

Мы находимся в активной фазе создания HERO!N. Вот что мы делаем прямо сейчас:

### ✅ Уже реализовано (базовые компоненты)
- **Bootstrap сервер** - базовая инфраструктура для discovery
- **P2P соединения** - через LibP2P и WebRTC
- **E2E шифрование** - ChaCha20-Poly1305 для сообщений
- **Android приложение** - базовый интерфейс и функциональность

### 🔄 В активной разработке
- **HERO Protocol** - наш специальный протокол для авто-роутинга
- **Space-Time Proofs** - система доказательств хранения для IPFS
- **Discovery механизм** - улучшенная система поиска серверов
- **Автономный режим** - работа без интернета через локальную сеть

### 📋 Планируется
- **i2p/tor интеграция** - для обхода блокировок
- **Community nodes** - поддержка серверов от энтузиастов
- **Machine learning** - для оптимизации маршрутизации
- **Desktop версия** - кроссплатформенный клиент

### 🧪 Тестируется
- **Географическая распределенность** - серверы в разных регионах
- **Scalability** - производительность при росте нагрузки
- **Resilience** - устойчивость к сбоям и атакам
- **User experience** - удобство использования

## Присоединяйся к революции!

*Это не завершенный проект, а живой процесс создания. Мы приглашаем всех, кто хочет участвовать в разработке по-настоящему свободной коммуникационной системы.*

## 📁 Структура проекта

```
├── backend/                    # Go backend
│   ├── cmd/                    # Точки входа (main.go)
│   ├── internal/               # Бизнес логика
│   │   ├── api/               # HTTP API сервер
│   │   ├── core/              # Ядро приложения (core.go)
│   │   ├── crypto/            # Криптография (engine.go)
│   │   ├── p2p/               # P2P сеть (в разработке)
│   │   └── storage/           # Хранилище (в разработке)
│   ├── pkg/                   # Переиспользуемые пакеты
│   ├── Dockerfile             # Docker образ для backend
│   ├── go.mod                # Go модули и зависимости
│   └── go.sum                # Контрольные суммы зависимостей
├── mobile/                    # Android приложение
│   ├── app/
│   │   ├── src/main/
│   │   │   ├── java/com/hero/kotlin/  # Kotlin исходный код
│   │   │   │   ├── MainActivity.kt   # Основная активность
│   │   │   │   └── ui/theme/         # Темы и стили
│   │   │   ├── AndroidManifest.xml   # Манифест приложения
│   │   │   └── res/                  # Ресурсы (в разработке)
│   │   └── build.gradle              # Gradle конфигурация
│   ├── build.gradle          # Корневая Gradle конфигурация
│   └── gradle/wrapper/       # Gradle wrapper
├── docs/                      # Документация
│   ├── architecture/          # Архитектура системы
│   ├── api/                   # API документация
│   └── guides/                # Руководства для разработчиков
├── docker/                    # Docker файлы и конфигурации
├── scripts/                   # Скрипты сборки и развертывания
├── .github/                   # GitHub настройки
│   ├── workflows/             # CI/CD пайплайны
│   │   └── ci.yml            # Основной CI/CD workflow
│   └── ISSUE_TEMPLATE/       # Шаблоны для issues
│       ├── bug_report.md     # Шаблон для баг-репортов
│       └── feature_request.md # Шаблон для фич-реквестов
├── docker-compose.yml         # Локальная разработка с Docker
├── Makefile                   # Команды для разработки
├── LICENSE                    # GPL-3.0 лицензия
├── CONTRIBUTING.md            # Руководство для контрибьюторов
├── CODE_OF_CONDUCT.md         # Кодекс поведения сообщества
├── .gitignore                # Исключаемые файлы для Git
└── README.md                 # Этот файл
```

## 🛠️ Быстрый старт

### Для разработчиков

```bash
# Клонируйте репозиторий
git clone https://github.com/c0rex86/hero-n.git
cd hero-n

# Запустите сервисы в Docker
make docker-up

# Соберите backend
make build-go

# Соберите Android приложение
make build-android

# Запустите тесты
make test
```

### Требования
- Go 1.21+ для backend
- Kotlin 1.9+ для Android
- Docker для развертывания
- Android Studio для мобильной разработки

Вместе мы создадим систему, которую нельзя сломать!

c0re & команда x.d.e.r
