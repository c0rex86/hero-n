ТЗ проекта Heroin

Кратко. Единое приложение, файловое хранилище и мессенджер. Сервер на Go. Клиент Android. Хранение файлов в IPFS, шифрование сквозное. Сеть p2p на базе libp2p и DHT. Маршрутизация устойчива к блокировкам. Транспорт многопротокольный, TCP, QUIC, WebSocket, WebTransport при необходимости. Авторизация username и password, доп ключ длиной десять символов с авто регенерацией. База данных SQLite. Сервер стартует как bootstrap, при наличии других узлов переходит в роль координации и помощи в обнаружении.

1. Цели и сценарии
1.1 Хранение файлов. Пользователь загружает файл. Клиент шифрует файл, публикует в IPFS, сохраняет только шифрованный вид. Метаданные хранятся в локальной базе и на сервере. Доступ к файлам возможен с других устройств пользователя через обмен ключами.
1.2 Мессенджер. Пользователь общается один на один и в группах. Сообщения шифруются сквозным протоколом. Для доставки используется p2p, при недоступности используется ретрансляция через сервер и libp2p relay.
1.3 Надежная сеть. Клиент умеет переключать транспорты. При блокировках использует реле, обход на базе wss и quic. Автоматическое обнаружение пиров и bootstrap узлов.

2. Нефункциональные требования
2.1 Безопасность. Современные алгоритмы, хранение ключей на устройстве, минимум доверия к серверу. Проверка целостности. Защита от повторов. Профилирование и аудит криптоконфигураций.
2.2 Производительность. Мегабайты в секунду на мобильной сети при передаче файлов. Средняя задержка сообщения не более двух секунд в онлайне. Быстрый старт с холодного состояния.
2.3 Надежность. Фоновая репликация пинов IPFS. Автовосстановление после сбоев сети. Идемпотентные операции.

3. Архитектура
3.1 Компоненты. Клиент Android. Сервер Go как bootstrap и вспомогательный ретранслятор. Узлы пользователей как p2p ноды. IPFS сеть для хранения и распространения блоков.
3.2 Потоки данных. Клиент шифрует файл, публикует в IPFS, передает получателям только cid и ключ в зашифрованном виде. Сообщения идут по p2p каналам, при недоступности используется relay и сервер как временный буфер с зашифрованными конвертами.
3.3 Разграничение доверия. Сервер не видит содержимое, хранит только служебные данные и публичные ключи. Клиент хранит приватные ключи в Android Keystore.

4. Криптография
4.1 Алгоритмы. Симметричное шифрование XChaCha20 Poly1305. Диффи Хеллман X25519. Подписи Ed25519. Хеш BLAKE3. KDF Argon2id. Генерация случайных значений через системный источник. Кодирование ключей в base64url.
4.2 Управление ключами. Главная пара для подписи и установления связи. Сессионные пары для диалога. Хранение приватных ключей в Android Keystore и защищенном хранилище на сервере отсутствует. Резервные копии ключей только по инициативе пользователя, зашифрованы парольной фразой.
4.3 E2E протокол сообщений. Инициализация через X3DH. Сеансовая передача на базе Double Ratchet с прерывистым перезапуском. Защита от повторов с помощью счетчиков и оконных фильтров. Отметки времени подписаны. Метаданные минимальны, содержат только адресацию и номер.
4.4 Шифрование файлов. На файл генерируется уникальный ключ и nonce. Файл шифруется потоково, ключ шифруется для каждого получателя по X25519 и прикладывается к конверту. Целостность проверяется через Poly1305 и BLAKE3 для кусочной валидации.

5. Сеть и маршрутизация
5.1 Транспорты. QUIC как основной, TCP как fallback, WebSocket поверх TLS для обхода ограничений, WebTransport при поддержке. Все соединения поверх TLS с корректным fingerprint через uTLS. Селектор транспорта учитывает тип сети и историю качества.
5.2 libp2p. DHT для поиска пиров. GossipSub для событий и оповещений. Circuit Relay v2 для обхода NAT. Hole punching с AutoNAT и AutoRelay. Рандеву сервер для встреч устройств одного пользователя.
5.3 Обнаружение. mDNS в локальной сети. Глобально через DHT и список bootstrap адресов. Список обновляется из конфигурации и через подписку на служебный топик.
5.4 Устойчивость к блокировкам. Маскировка под обычный трафик TLS. WSS на стандартных портах. Использование DoH для резолва. Переключение доменов. Ротация портов. При жестких ограничениях переход на relay цепочки из доверенных нод.
5.5 Планировщик маршрутов. Каждому кандидату присваивается стоимость. На вход идут задержка, потери, стабильность, вероятность блокировки, загрузка. Выбирается маршрут с минимальной стоимостью. Проводится активный пробинг в фоне. При деградации выполняется быстрый переключатель с сохранением сеанса при помощи миграции транспорта.
5.6 Приоритеты. Прямое p2p соединение. Затем relay v2. Затем серверный ретранслятор. Затем офлайн доставка через зашифрованные конверты на сервере до появления адресата.

6. IPFS хранение
6.1 Публикация. Клиент шифрует, собирает CAR, публикует блоки. На сервер по желанию отправляется запрос на пин и репликацию. Репликация на N узлов по политике.
6.2 Доступ. Клиент достает блоки по cid через локальный узел или через шлюз партнеров. Всегда проверяет целостность. При нехватке частей использует несколько провайдеров параллельно.
6.3 Метаданные. В базе хранятся описание, размер, mime, cid, схема шифрования, отметки времени, владельцы и список получателей.

7. Сервер Go
7.1 Роли. Bootstrap, ретрансляция, пиннинг IPFS, минимальные учетные операции. gRPC и HTTP API. Механизм очередей для офлайн доставки зашифрованных конвертов.
7.2 База данных. SQLite с WAL. Миграции. Индексы по пользователям и cid. Журналирование аудита входов и смен ключей.
7.3 Конфигурация. YAML. Порты для tcp и quic. Список bootstrap адресов и реле. Настройки IPFS и пиннинга. Параметры KDF и сроков токенов.
7.4 Наблюдаемость. Логи в JSON. Метрики Prometheus. Трассировка OpenTelemetry. Рейтконтроль и защитa от перегрузки.

8. Клиент Android
8.1 Архитектура. Модули ядра для сети, крипто, хранилища. Фичи для чатов, файлов, авторизации, настроек. Чистая архитектура, MVVM, Kotlin coroutines, Flow.
8.2 UI. Jetpack Compose. Светлая и темная тема. Экран чатов, диалог, список файлов, просмотр, загрузка, настройки устройств и ключей. Упор на простоту и ясность.
8.3 Сеть. libp2p клиент или тонкая обертка над go libp2p через gRPC и wss. Поддержка quic и tcp. Менеджер транспорта и роутер в общем модуле core network.
8.4 Крипто. Android Keystore. libsodium для XChaCha20 Poly1305 и X25519. Безопасное хранилище сеансовых ключей. Автоматическое пересоздание ратчетов.
8.5 Хранилище. Работа с IPFS через локальный узел на устройстве или удаленный API. Кэш и предзагрузка по wi fi.

9. Авторизация и учет
9.1 Регистрация. Username уникальный. Пароль проходит Argon2id на клиенте, потом снова на сервере с собственной солью. Создается пара ключей. Публик ключ публикуется. Приватный хранится только у клиента.
9.2 Логин. Клиент отправляет username и доказательство знания пароля через SRP или PAKE. После успеха выдается PASETO токен. Освежение по refresh токену. Сессия привязана к устройству.
9.3 Доп ключ. Второй фактор длиной десять символов. Генерируется автоматически на устройстве, ротируется каждые тридцать минут, хранится в защищенном виде. При логине отправляется одноразовый код, проверка на сервере с допуском времени.

10. Протоколы и сообщения
10.1 Модель. Envelope с минимальными метаданными, зашифрованная полезная нагрузка, подпись отправителя. Нумерация и дедупликация. Для групп ключи на группу и пересылка по участникам.
10.2 Сервисы. Auth, Messaging, Storage. Публичные proto схемы в каталоге shared proto. Версионирование по префиксу v1.

11. Маршрутизация детально
11.1 Таблица кандидатов. Прямой p2p адрес, адреса через релеи, адрес сервера ретранслятора, адреса шлюзов ipfs. Каждому кандидату присваивается надежность и стоимость.
11.2 Метрики. Средняя задержка, процент потерь, джиттер, количество разрывов, доля успешных соединений, заметные блокировки на маршруте. Хранение скользящим окном.
11.3 Алгоритм выбора. Инициализация быстрым пробингом. Выбор по минимальной стоимости. Миграция сеанса без разрыва при смене транспорта. Таймауты адаптивные.
11.4 Обход. При блокировках попытка через wss на порте четыреста сорок три, затем quic на альтернативных доменах, затем relay. Резерв через серверный буфер.
11.5 Конфигурация. Порог переключения и веса метрик конфигурируются.

12. Схема данных
12.1 Таблицы. users, devices, sessions, files, messages, peers, pins. Для всех важные индексы. Внешние ключи. Журнал аудита для входов и смен ключей.
12.2 Идентификаторы. UUID v7. Времена в UTC. Размеры в байтах.

13. План реализации
13.1 Этап один. База проекта, протоколы, авторизация, базовый p2p, публикация и загрузка файлов с шифрованием, простые чаты один на один.
13.2 Этап два. Группы, офлайн доставка, репликация пинов, адаптивная маршрутизация, наблюдаемость и алерты.
13.3 Этап три. Оптимизация, энергоэффективность, тонкая настройка качества сервиса, тестирование на реальной сети.

14. Критерии готовности
14.1 Вход по username и password и второму фактору. Отправка и прием сообщений с e2e. Загрузка и скачивание файла через IPFS с проверкой целостности. Автоматическое переключение транспорта при деградации.

15. Структура репозитория
15.1 docs TZ.md
15.2 server cmd heroin server
15.3 server internal auth, crypto, ipfs, messaging, api http и grpc, routing, store, config, bootstrap, discovery
15.4 server configs, migrations
15.5 client android app, core network, core crypto, core storage, feature messenger, feature files, feature auth, feature settings
15.6 shared proto
15.7 scripts, docker

16. Требования к коду
16.1 Чистая архитектура, границы модулей стабильны. Конфигурация вместо хардкода. Логи и метрики везде. Ошибки с контекстом. Комментарии короткие и только по делу.

17. Тестирование
17.1 Покрытие единицами критичных частей крипто и маршрутизации. Интеграционные тесты p2p. Нагрузочные на пиннинг и доставку.

18. Риски
18.1 Блокировки сетевых протоколов. Решение в виде wss и relay. 18.2 Потеря ключа. Решение в виде резервной фразы у пользователя. 18.3 Перегрузка серверов. Решение в виде автоматического масштабирования реле и пиннеров.

19. Задачи для реализации по модулям
19.1 Сервер. Инициализация конфигурации. gRPC и HTTP. Auth и токены. Очередь конвертов. Пиннинг IPFS. Метрики и логи.
19.2 Клиент. Keystore, крипто ядро, менеджер транспорта и роутер, IPFS клиент, чаты и файлы, UI Compose, офлайн кэш.
19.3 Протоколы. Определить proto, собрать stubs, подключить версии.

Примечание. Доп ключ ровно десять символов. Ротация по времени. Верификация с допустимым окном времени. В клиенте отображается время до ротации. В сервере хранится только проверочный секрет для генерации кода и счетчик времени.
